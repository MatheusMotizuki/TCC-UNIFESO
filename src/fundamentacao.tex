\chapter[Fundamentação]{Fundamentação Teórica}

Na presente seção serão abordados tópicos específicos sobre programação e processamento de imagens que são fundamentais para a compreensão do presente trabalho. Inicialmente, será apresentado, de forma breve, os principais elementos que compõem a base do sistema desenvolvido, incluindo a linguagem escolhida para o desenvolvimento do aplicativo, bibliotecas, aspectos de UI/UX e sua importância para este projeto, bem como o paradigma de desenvolvimento adotado, sendo considerado um dos diferenciais do projeto.

Posteriormente, será abrangido o tema de processamento de imagens, em maior profundidade,e suas aplicações neste trabalho, com ênfase nos conceitos práticos que embasam sua aplicação no projeto. Por fim, será discutido o processo de criação e utilização dos \textit{Shaders}, explicando seu funcionamento e importância.

\section{Python}

Python, uma linguagem de programação alto nível e propósito geral, amplamente reconhecida por sua simplicidade sintática, legibilidade e ampla comunidade de usuários. Sua praticidade e versatilidade tornam-no uma escolha popular em diversas áreas da computação, incluindo, mas não se limitando a, ciência de dados, automação desenvolvimento web e processamento de imagens \cite{Python}.

Nesse contexto, o Python se destaca por oferecer um ecossistema robusto de bibliotecas especializadas, como OpenCV, NumPy, Scikit-image, Pillow, entre outras, que permitem desde simples operações de manipulação de imagem até o desenvolvimento de algorítimos avançados de análise, restauração e aperfeiçoamento visual.
Essa ampla gama de recursos torna a linguagem uma ferramenta altamente eficaz para projetos que exigem processamento e tratamento de imagens digitais, como é o caso deste trabalho \cite{PillowDocs, PyOpenCV, NumPy, scikit-image}.

\section{Bibliotecas}

Bibliotecas, no sentido tradicional, são locais onde inúmeros livros são  armazenados para consulta, permitindo que os leitores adquiram conhecimento em diversas áreas e sobre os mais variados temas. As bibliotecas de programação seguem um conceito semelhante sendo elas, coleções de funções, rotinas ou módulos reutilizáveis, escritas em determinada linguagem de programação \cite{GeeksForGeeks}. E assim como livros, aonde releituras ou adaptações são constantemente criadas, as bibliotecas também passam por esse mesmo processo, dependendo da licença de uma biblioteca, ela pode ser reescrita em outra linguagem, ou adaptada como um binding ou wrapper, ou uma nova versão pode ser refeita, por uma pessoa diferente ou pelo criador original da mesma \cite{bind-wrap}.

Nesta seção serão abordadas as bibliotecas utilizadas neste projeto, tanto de processamento de imagens como de interface de usuário.

\subsection{Dear PyGui}

O Dear PyGui (DPG) é uma biblioteca para Python rápida e poderosa para a criação de interfaces gráficas, originalmente desenvolvida em C++ sob o nome de Dear ImGui (\textit{Immediate-Mode Graphical User Interface}). Devido a crescente popularidade da linguagem Python, a biblioteca foi adaptada para esse ambiente, mantendo os princípios de interface em modo imediato e oferecendo uma API simplificada e eficiente \cite{DearPyGui}.

O Dear PyGui (DPG) segue o paradigma de GUI em modo imediato (“Immediate mode GUI”) que, ao invés de manter uma árvore de componentes entre interações, como ocorre no modo retido (retained mode), o framework desenha a interface a cada frame com base no estado atual da aplicação \cite{DPGdocs, ImGui, immediate-modeGUI}.

No modo retido (\textit{retained mode}), frameworks que utilizam esse estilo armazenam os elementos da interface, como botões, janelas e caixas de texto, em uma árvore ou hierarquia de componentes. A biblioteca gerencia automaticamente os estados dos elementos e atualiza apenas aqueles que sofrem alterações, ou seja, elementos cujo estado, cor, tamanho ou outras propriedades foram modificados pelo usuário ou por outro componente.

Um exemplo de tecnologia amplamente conhecida por utilizar esse método é o CSS (\textit{Cascading Style Sheets}), que mantém o estado de cada elemento em uma estrutura hierárquica e realiza a atualização somente do elemento que foi interagido ou afetado por alterações \cite{MDNdocs}.

Entretanto, um dos problemas associados a esse modelo de interface é justamente o gerenciamento de estados. Em aplicações com muitos componentes, esse controle pode se tornar difícil de manter, gerando error que passam despercebidos. Por exemplo, ao deletar um componente e, inadvertidamente, tentar modificar o estado do mesmo, cuja referência ainda permaneça em algum ponto da hierarquia, isso acabaria causando em um erro, pois, o elemento modificado não estará mais presente na hierarquia.

No modo imediato, característico da biblioteca Dearpygui, exige que os elementos sejam desenhados a cada ciclo de atualização, ou a cada frame. Isso oferece alto controle e facilita a criação de interfaces altamente dinâmicas e responsivas, especialmente em tempo real \cite{retain-immediate}. Computadores mais fracos, em relação a CPU, acabam sofrendo com aplicações que utilizam esse modo de interface gráfica.

\subsection{PILLOW}

A biblioteca Pillow é uma continuação aprimorada e mantida até os dias atuais, originalmente desenvolvida sob o nome de PIL (Python Imaging Library) feita por Fredrik Lundh \cite{Pillow-Docs}, amplamente utilizada para processamento de imagens em Python. O pillow surgiu como uma fork do PIL, garantindo uma compatibilidade retroativa e adicionando suporte a recursos modernos, além da manutenção continua da comunidade \textit{open source}.

A biblioteca oferece uma ampla variedade de funcionalidades, como a abertura e a possibilidade de salvar imagens em diversos formatos como por exemplo, JPEG, PNG, BMP GIF e TIFF, além de suas outras funcionalidades como redimensionamento de imagens, corte, filtros alteração de cores entre outras \cite{PillowDocs}.

\subsection{PyOpenGL}

O PyOpenGL é um conjunto de bindings (ligações) em Python para a biblioteca gráfica OpenGL, permitindo que programas escritos em Python façam o uso direto dessa API de gráficos 2D e 3D. Por meio dela, é possível acessar praticamente todas as funcionalidades da API OpenGL, inclusive extensões modernas como shaders em GLSL. O PyOpenGL é multiplataforma, e é amplamente utilizado para o desenvolvimento de visualizações científicas, simulações e jogos \cite{PyOpenGl}.

\section{Shaders}

Shaders são pequenos programas que são executados diretamente na GPU (Graphical Process Unit), responsáveis por controlar o processamento de vértices e pixels durante o pipeline gráfico. Escritos geralmente em linguagens como GLSL (OpenGL Shading Language), permitem criar efeitos visuais complexos, como iluminação dinâmica, mapeamento de texturas, sombras e reflexos. Os tipos mais comuns de shaders são dois, \textit{vertex shaders}, que manipulam posições e propriedades dos vértices, e os \textit{fragment shaders} que determina a cor final de cada fragmento (pixel) renderizado \cite{GLSLang}.

\section{UI/UX}

A área de \textit{User Interface/User Experience} representa um aspecto essencial no desenvolvimento de qualquer software sendo, site ou aplicativo. Uma interface mal projetada pode comprometer significativamente a usabilidade da aplicação, deixando-a confusa e pouco intuitiva.

No contexto deste trabalho, a atenção à UI/UX foi uma das prioridades no processo de desenvolvimento. A proposta do aplicativo de ser de fácil utilização e rápido aprendizado, busca se distanciar de soluções complexas, constantemente acompanhadas com funcionalidades ocultas ou mal estruturadas.

\section{Dataflow}

"Dataflow programming (DFP) é um paradigma de programação, onde a execução do programa é conceitualizada como dados fluindo por uma série de operações ou transformações" \cite{devopedia}. Diferente dos paradigmas tradicionais imperativos, onde o controle do fluxo é determinando pela sequência explícita de instruções, na PFD o foco está no fluxo dos dados e na maneira como eles propagam pelos nós (ou blocos funcionais) do sistema. Nesse modelo, cada operação ou nó executa seu processamento assim que todos os dados necessários para sua execução estão disponíveis, independentemente de uma ordem de execução global. Isso torna a PFD naturalmente concorrente e paralelizável, uma vez que operações independentes podem ser executadas simultaneamente sempre que seus dados estiverem disponíveis \cite{lee-parks}.

Entre as principais características da PFD, destaca-se a execução orientada a dados. A execução de cada nó é acionada pela chegada de dados completos, dispensando o uso de estruturas tradicionais de controle de fluxo como por exemplo loops ou comandos condicionais. Ademais, como os nós são independentes, podem ser mapeados facilmente para diferentes threads ou até mesmo para processadores distintos, explorando ao máximo arquiteturas multicore e distribuídas \cite{ackerman.w.b}. O modelo PFD contribui para a tolerância a latências, pois em sistemas distribuídos ou heterogêneos diferentes nós podem prosseguir com o processando dados independentemente do tempo de processamento de outros nós. \cite{malteschwarzkopf}

O Dataflow possui múltiplas implementações. Uma das implementações clássicas e mais simples é o modelo baseado em tokens, no qual os dados fluem pelos grafos na forma de tokens que transitam por filas do tipo FIFO (first in, first out) \cite{JohnstonHannaMillar, malteschwarzkopf}. Quando os dados necessários estão disponíveis nas entradas de um nó, ele é denominado de um nó \textit{fireable}, ou seja, o node está pronto para ser executado. Um nó \textit{fireable} será executado após um determinado intervalo de tempo desde o recebimento de seus dados. Passando esse período, ele é ativado, seus tokens de saída avançam para o próximo nó, o qual poderá então se tornar \textit{fireable}. O nó anterior, por sua vez, perde a denominação de \textit{fireable}, retorna ao seu estado padrão e aguarda até que o processo possa se repetir.

De forma geral, programas de fluxo de dados são representados por grafos direcionados, nos quais os nós (ou vértices) representam operações ou transformações sobre os dados, enquanto arestas representam canais por onde os dados circulam entre operações. Esse grafo pode ser estático ou dinâmico. Em grafos estáticos, a estrutura do fluxo é conhecida em tempo de compilação, o que facilita otimização e analises. Entretanto, certos programas não podem ser representados por esse tipo de grafo, pois laços (loops), por exemplo, só podem ser modelados caso o número de iterações já seja conhecido em tempo de compilação. Já os grafos dinâmicos, oferecem uma maior flexibilidade, permitindo que nós com múltiplos arcos sejam diferenciados por cores, em que cada cor é ativada exclusivamente para seu arco específico \cite{JohnstonHannaMillar}.

Em comparação com a tradicional programação imperativa, a PFD não depende de uma sequencia explícita de instruções, mas sim das dependências entre dados. Já em relação à programação funcional, embora ambos incentivem programas sem efeitos colaterais e baseados em composição, a PFD enfatiza o movimento e a dependência de dados entre operações, enquanto a programação funcional foca principalmente em funções puras e transformações sobre coleções \cite{lee-parks}.

A adoção desse paradigma traz diversas vantagens. O paralelismo surge de forma implícita, eliminando a necessidade de escrever explicitamente código de sincronização, pois o próprio modelo organiza as dependências de dados. Além disso, muitas implementação de PFD garantem determinismo, assegurando que, dado o mesmo conjunto de entradas, o programa sempre produzirá o mesmo resultado, independentemente da ordem em que as operações internas são realizadas.

\section{Teoria dos grafos}

A teoria dos grafos é um ramo da matemática discreta que estuda as relações entre objetos representados por meio de estruturas chamadas grafos. Um grafo é definido, formalmente, como um par ordenado \(G = (V, A)\), onde \(V\) é um conjunto de vértices (ou nós), e \(A\) é o conjunto de arestas que conectam pares de vértices. Dependendo do problema ou da aplicação, grafos podem ser direcionados ou não direcionados \cite{graph-theory-1}.

Nos grafos não direcionados, as conexões entre vértices (ou nós) não possuem direção ou sentido específico; já nos grafos direcionados, cada aresta possui sentido definido, sendo por isso também chamado de arco.

A origem formal do estudo dos grafos é atribuída ao matemático Leonhard Euler, que em 1736 discutiu o famoso enigma das pontes de Königsberg, estabelecendo assim os fundamentos do que hoje é conhecido como teoria dos grafos. Desde então, o campo expandiu-se substancialmente, encontrando aplicações em diversas áreas, como ciência da computação, engenharia elétrica, biologia, logística e redes sociais \cite{graph-theory-2}.